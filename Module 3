#!/usr/bin/env python3
"""
Module: advanced_dashboard.py
Purpose: Advanced Visualization & Control Interface for the Adaptive Resource Allocation System.

This Dash application displays real-time (simulated) aggregated system metrics and resource allocation decisions.
It includes real-time graphs, manual threshold adjustments, and a manual refresh option.
The layout is styled using Bootstrap for a polished appearance.
"""

import dash
import dash_bootstrap_components as dbc
from dash import html, dcc, Output, Input, State
import plotly.graph_objs as go
import json
import time
import random

# ---------------------------
# Simulated Data Functions
# ---------------------------
def simulate_aggregated_metrics():
    """
    Simulates aggregated system metrics with slight random fluctuations.
    
    Returns:
        dict: Simulated aggregated metrics.
              Example structure:
              {
                  "cpu_percent": {"avg": 85.0, "min": 80.0, "max": 90.0, "std": 3.0},
                  "memory_percent": {"avg": 70.0, "min": 65.0, "max": 75.0, "std": 2.5},
                  "timestamp": "2025-02-14T17:06:48Z"
              }
    """
    base_cpu = 85.0 + random.uniform(-2, 2)
    base_mem = 70.0 + random.uniform(-2, 2)
    simulated_data = {
        "cpu_percent": {
            "avg": round(base_cpu, 1),
            "min": round(base_cpu - 5, 1),
            "max": round(base_cpu + 5, 1),
            "std": 3.0
        },
        "memory_percent": {
            "avg": round(base_mem, 1),
            "min": round(base_mem - 5, 1),
            "max": round(base_mem + 5, 1),
            "std": 2.5
        },
        "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    }
    return simulated_data

def simulate_decision_output(aggregated_metrics, cpu_threshold, mem_threshold):
    """
    Applies rule-based decision logic to simulated aggregated metrics.
    
    Parameters:
        aggregated_metrics (dict): Aggregated metrics dictionary.
        cpu_threshold (float): Manual CPU threshold.
        mem_threshold (float): Manual Memory threshold.
    
    Returns:
        dict: Decision output.
    """
    cpu_avg = aggregated_metrics["cpu_percent"]["avg"]
    mem_avg = aggregated_metrics["memory_percent"]["avg"]
    
    decision = {
        "timestamp": aggregated_metrics["timestamp"],
        "cpu_adjustment": "reduce_non_critical" if cpu_avg > cpu_threshold else "normal",
        "memory_adjustment": "flag_high_usage" if mem_avg > mem_threshold else "normal",
        "details": {
            "cpu_avg": cpu_avg,
            "memory_avg": mem_avg
        }
    }
    return decision

# ---------------------------
# Create the Dash Application
# ---------------------------
external_stylesheets = [dbc.themes.BOOTSTRAP]
app = dash.Dash(__name__, external_stylesheets=external_stylesheets)

# Layout of the dashboard using Bootstrap and html.Div for form groups
app.layout = dbc.Container([
    dbc.Row(
        dbc.Col(html.H1("Adaptive Resource Allocation Dashboard", className="text-center my-4"), width=12)
    ),
    dbc.Row([
        dbc.Col(
            dbc.Card([
                dbc.CardHeader("Aggregated System Metrics"),
                dbc.CardBody(
                    dcc.Graph(id="cpu-graph")
                )
            ], className="mb-4"),
            width=6
        ),
        dbc.Col(
            dbc.Card([
                dbc.CardHeader("Memory Usage Over Time"),
                dbc.CardBody(
                    dcc.Graph(id="memory-graph")
                )
            ], className="mb-4"),
            width=6
        )
    ]),
    dbc.Row([
        dbc.Col(
            dbc.Card([
                dbc.CardHeader("Resource Allocation Decision"),
                dbc.CardBody(
                    html.Pre(id="decision-output", style={"whiteSpace": "pre-wrap", "fontFamily": "monospace"})
                )
            ], className="mb-4"),
            width=12
        )
    ]),
    dbc.Row([
        dbc.Col([
            # Replacing dbc.FormGroup with html.Div with className "form-group"
            html.Div([
                dbc.Label("CPU Threshold (%)"),
                dcc.Slider(
                    id="cpu-threshold-slider",
                    min=50,
                    max=100,
                    step=1,
                    value=80,
                    marks={i: str(i) for i in range(50, 101, 10)},
                    tooltip={"placement": "bottom", "always_visible": True}
                )
            ], className="form-group"),
            html.Div([
                dbc.Label("Memory Threshold (%)"),
                dcc.Slider(
                    id="mem-threshold-slider",
                    min=50,
                    max=100,
                    step=1,
                    value=75,
                    marks={i: str(i) for i in range(50, 101, 10)},
                    tooltip={"placement": "bottom", "always_visible": True}
                )
            ], className="form-group"),
            dbc.Button("Refresh Now", id="refresh-button", color="primary", className="mr-3"),
            html.Br(), html.Br(),
            html.Div([
                dbc.Label("Auto-Refresh Interval (seconds)"),
                dcc.Slider(
                    id="interval-slider",
                    min=1,
                    max=10,
                    step=1,
                    value=5,
                    marks={i: str(i) for i in range(1, 11)},
                    tooltip={"placement": "bottom", "always_visible": True}
                )
            ], className="form-group"),
            # Hidden store for historical data
            dcc.Store(id="history-store", data={"timestamps": [], "cpu_avgs": [], "mem_avgs": []}),
            # Interval component for auto-refresh
            dcc.Interval(id="interval-component", interval=5*1000, n_intervals=0)
        ], width=12)
    ])
], fluid=True)

# ---------------------------
# Callbacks for updating the dashboard
# ---------------------------
@app.callback(
    [Output("cpu-graph", "figure"),
     Output("memory-graph", "figure"),
     Output("decision-output", "children"),
     Output("history-store", "data"),
     Output("interval-component", "interval")],
    [Input("interval-component", "n_intervals"),
     Input("refresh-button", "n_clicks"),
     Input("cpu-threshold-slider", "value"),
     Input("mem-threshold-slider", "value"),
     Input("interval-slider", "value")],
    [State("history-store", "data")]
)
def update_dashboard(n_intervals, n_clicks, cpu_threshold, mem_threshold, refresh_interval, history):
    # Simulate aggregated metrics
    aggregated = simulate_aggregated_metrics()
    decision = simulate_decision_output(aggregated, cpu_threshold, mem_threshold)
    
    # Update history store with current sample
    timestamp = aggregated["timestamp"]
    cpu_avg = aggregated["cpu_percent"]["avg"]
    mem_avg = aggregated["memory_percent"]["avg"]
    
    history["timestamps"].append(timestamp)
    history["cpu_avgs"].append(cpu_avg)
    history["mem_avgs"].append(mem_avg)
    
    # Create line graph for CPU
    cpu_fig = {
        "data": [go.Scatter(
            x=list(range(len(history["cpu_avgs"]))),
            y=history["cpu_avgs"],
            mode="lines+markers",
            name="CPU Avg (%)"
        )],
        "layout": go.Layout(
            title="CPU Usage Over Time",
            xaxis=dict(title="Sample"),
            yaxis=dict(title="CPU Avg (%)", range=[0, 100])
        )
    }
    
    # Create line graph for Memory
    mem_fig = {
        "data": [go.Scatter(
            x=list(range(len(history["mem_avgs"]))),
            y=history["mem_avgs"],
            mode="lines+markers",
            name="Memory Avg (%)"
        )],
        "layout": go.Layout(
            title="Memory Usage Over Time",
            xaxis=dict(title="Sample"),
            yaxis=dict(title="Memory Avg (%)", range=[0, 100])
        )
    }
    
    decision_str = json.dumps(decision, indent=4)
    # Set auto-refresh interval based on slider (convert seconds to milliseconds)
    interval_ms = refresh_interval * 1000
    
    return cpu_fig, mem_fig, decision_str, history, interval_ms

# ---------------------------
# Run the Dash Application
# ---------------------------
if __name__ == "__main__":
    app.run_server(debug=True)
